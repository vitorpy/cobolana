/*
 * sBPF Code Generator for GNU COBOL
 * Replaces standard C codegen with Solana BPF assembly output
 */

#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "cobc.h"
#include "tree.h"

/* Helper to sanitize field names for assembly labels */
static void
fprintf_sanitized_name(FILE *out, const char *prefix, const char *name)
{
	fprintf(out, "%s", prefix);
	for (const char *p = name; *p; p++) {
		if (*p == '-') {
			fputc('_', out);
		} else {
			fputc(*p, out);
		}
	}
}

/*
 * Generate Solana BPF assembly from COBOL AST
 */
void
codegen(struct cb_program *prog, const char *translate_name)
{
	FILE *out;
	struct cb_field *f;
	cb_tree stmt;
	struct cb_call *call;
	struct cb_literal *lit;


	/* Open output file */
	out = fopen(translate_name, "w");
	if (!out) {
		fprintf(stderr, "Failed to open output file: %s\n", translate_name);
		cobc_abort_terminate (0);
	}

	fprintf(out, "# Generated by cobolana-compiler (sBPF backend)\n");
	fprintf(out, "# COBOL Program: %s\n\n", prog->program_id);

	/*
	 * Emit .rodata section with string literals
	 */
	fprintf(out, ".section .rodata\n");
	for (f = prog->working_storage; f; f = f->sister) {
		/* Skip if no value or not a literal */
		if (!f->values || !CB_LITERAL_P(f->values)) {
			continue;
		}

		lit = CB_LITERAL(f->values);

		/* Only handle alphanumeric literals */
		if (CB_TREE_CATEGORY(f->values) != CB_CATEGORY_ALPHANUMERIC) {
			continue;
		}

		/* Emit the string data as .ascii directive */
		fprintf_sanitized_name(out, "msg_", f->name);
		fprintf(out, ":\n  .ascii \"");
		for (unsigned int i = 0; i < lit->size; i++) {
			unsigned char c = lit->data[i];
			if (c >= 32 && c < 127 && c != '"' && c != '\\') {
				fprintf(out, "%c", c);
			} else {
				fprintf(out, "\\x%02x", c);
			}
		}
		fprintf(out, "\"\n\n");

	}

	/*
	 * Emit .text section
	 */
	fprintf(out, ".text\n");
	fprintf(out, ".globl entrypoint\n\n");
	fprintf(out, "entrypoint:\n");

	/* Walk the execution list */
	for (stmt = prog->exec_list; stmt; stmt = CB_CHAIN(stmt)) {
		cb_tree actual_stmt, body;

		/* exec_list is a list of lists - get the actual statement */
		actual_stmt = CB_VALUE(stmt);
		if (!actual_stmt) {
			continue;
		}

		/* Statements are wrapped in cb_statement structures */
		if (!CB_STATEMENT_P(actual_stmt)) {
			continue;
		}

		body = CB_STATEMENT(actual_stmt)->body;
		if (!body) {
			continue;
		}

		/* If body is a list, unwrap it */
		if (CB_LIST_P(body)) {
			body = CB_VALUE(body);
			if (!body) {
				continue;
			}
		}

		if (!CB_CALL_P(body)) {
			continue;
		}

		call = CB_CALL(body);

		/* Check if it's a sol_log_ call */
		if (CB_LITERAL_P(call->name)) {
			lit = CB_LITERAL(call->name);
			if (lit->size == 8 && memcmp(lit->data, "sol_log_", 8) == 0) {
				/* Get first argument (should be a field reference) */
				cb_tree arg = NULL;
				if (call->args && CB_LIST_P(call->args)) {
					arg = CB_VALUE(call->args);
				} else {
					arg = call->args;
				}

				if (arg && CB_REFERENCE_P(arg)) {
					struct cb_reference *ref = CB_REFERENCE(arg);
					struct cb_field *msg_field = CB_FIELD(ref->value);

					/* Emit sol_log_ syscall */
					fprintf(out, "  # CALL sol_log_(%s, %d)\n",
						msg_field->name, msg_field->size);
					fprintf(out, "  lddw r1, ");
					fprintf_sanitized_name(out, "msg_", msg_field->name);
					fprintf(out, "\n  lddw r2, %d\n", msg_field->size);
					fprintf(out, "  call sol_log_\n");

				} else if (CB_FIELD_P(arg)) {
					struct cb_field *msg_field = CB_FIELD(arg);

					fprintf(out, "  # CALL sol_log_(%s, %d)\n",
						msg_field->name, msg_field->size);
					fprintf(out, "  lddw r1, ");
					fprintf_sanitized_name(out, "msg_", msg_field->name);
					fprintf(out, "\n  lddw r2, %d\n", msg_field->size);
					fprintf(out, "  call sol_log_\n");

				}
			}
		}
	}

	/* Exit program */
	fprintf(out, "  exit\n");

	fclose(out);

	/* Exit successfully - don't try to compile the assembly as C */
	exit(0);
}

/* Stub for clear_local_codegen_vars */
void
clear_local_codegen_vars(void)
{
	/* Nothing to clear in our simple backend */
}

/* Stub for cobc_init_codegen */
void
cobc_init_codegen(void)
{
	/* Nothing to initialize */
}
