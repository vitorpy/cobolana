/*
 * sBPF Code Generator for GNU COBOL
 * Replaces standard C codegen with Solana BPF assembly output
 */

#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "cobc.h"
#include "tree.h"

/*
 * Generate Solana BPF assembly from COBOL AST
 */
void
codegen(struct cb_program *prog, const char *translate_name)
{
	FILE *out;
	struct cb_field *f;
	cb_tree stmt;
	struct cb_call *call;
	struct cb_literal *lit;


	/* Open output file */
	out = fopen(translate_name, "w");
	if (!out) {
		fprintf(stderr, "Failed to open output file: %s\n", translate_name);
		cobc_abort_terminate (0);
	}

	fprintf(out, "; Generated by cobolana-compiler (sBPF backend)\n");
	fprintf(out, "; COBOL Program: %s\n\n", prog->program_id);

	/*
	 * Emit .rodata section with string literals
	 */
	fprintf(out, ".section .rodata\n");
	for (f = prog->working_storage; f; f = f->sister) {
		/* Skip if no value or not a literal */
		if (!f->values || !CB_LITERAL_P(f->values)) {
			continue;
		}

		lit = CB_LITERAL(f->values);

		/* Only handle alphanumeric literals */
		if (CB_TREE_CATEGORY(f->values) != CB_CATEGORY_ALPHANUMERIC) {
			continue;
		}

		/* Emit the string data */
		fprintf(out, "msg_%s:\n", f->name);
		fprintf(out, "    .byte ");
		for (unsigned int i = 0; i < lit->size; i++) {
			fprintf(out, "0x%02x", lit->data[i]);
			if (i < lit->size - 1) fprintf(out, ", ");
		}
		fprintf(out, "\n");

		/* Emit the length as a constant */
		fprintf(out, "msg_%s_len:\n", f->name);
		fprintf(out, "    .word %u\n", lit->size);
		fprintf(out, "\n");

	}

	/*
	 * Emit .text section
	 */
	fprintf(out, ".section .text\n");
	fprintf(out, ".globl entrypoint\n");
	fprintf(out, "entrypoint:\n");

	/* Walk the execution list */
	for (stmt = prog->exec_list; stmt; stmt = CB_CHAIN(stmt)) {
		cb_tree actual_stmt, body;

		/* exec_list is a list of lists - get the actual statement */
		actual_stmt = CB_VALUE(stmt);
		if (!actual_stmt) {
			continue;
		}

		/* Statements are wrapped in cb_statement structures */
		if (!CB_STATEMENT_P(actual_stmt)) {
			continue;
		}

		body = CB_STATEMENT(actual_stmt)->body;
		if (!body) {
			continue;
		}

		/* If body is a list, unwrap it */
		if (CB_LIST_P(body)) {
			body = CB_VALUE(body);
			if (!body) {
				continue;
			}
		}

		if (!CB_CALL_P(body)) {
			continue;
		}

		call = CB_CALL(body);

		/* Check if it's a sol_log_ call */
		if (CB_LITERAL_P(call->name)) {
			lit = CB_LITERAL(call->name);
			if (lit->size == 8 && memcmp(lit->data, "sol_log_", 8) == 0) {
				/* Get first argument (should be a field reference) */
				cb_tree arg = NULL;
				if (call->args && CB_LIST_P(call->args)) {
					arg = CB_VALUE(call->args);
				} else {
					arg = call->args;
				}

				if (arg && CB_REFERENCE_P(arg)) {
					struct cb_reference *ref = CB_REFERENCE(arg);
					struct cb_field *msg_field = CB_FIELD(ref->value);

					/* Emit sol_log_ syscall */
					fprintf(out, "    ; CALL sol_log_(%s, %d)\n",
						msg_field->name, msg_field->size);
					fprintf(out, "    lddw %%r1, msg_%s\n", msg_field->name);
					fprintf(out, "    mov %%r2, %d\n", msg_field->size);
					fprintf(out, "    call 0x207559bd  ; sol_log_ syscall hash\n");

				} else if (CB_FIELD_P(arg)) {
					struct cb_field *msg_field = CB_FIELD(arg);

					fprintf(out, "    ; CALL sol_log_(%s, %d)\n",
						msg_field->name, msg_field->size);
					fprintf(out, "    lddw %%r1, msg_%s\n", msg_field->name);
					fprintf(out, "    mov %%r2, %d\n", msg_field->size);
					fprintf(out, "    call 0x207559bd  ; sol_log_ syscall hash\n");

				}
			}
		}
	}

	/* Return 0 */
	fprintf(out, "    mov %%r0, 0\n");
	fprintf(out, "    exit\n");

	fclose(out);
}

/* Stub for clear_local_codegen_vars */
void
clear_local_codegen_vars(void)
{
	/* Nothing to clear in our simple backend */
}

/* Stub for cobc_init_codegen */
void
cobc_init_codegen(void)
{
	/* Nothing to initialize */
}
