# üî• COBOLANA - COBOL on Solana

> **Because 1959 deserves to run on the blockchain.**

The world's most absurd compiler: Enterprise COBOL ‚Üí Solana BPF bytecode.

**It actually works.** ‚úÖ

### Example 1: Hello World

```cobol
IDENTIFICATION DIVISION.
PROGRAM-ID. COBOLANA.

DATA DIVISION.
WORKING-STORAGE SECTION.
01 HELLO-MSG PIC X(14) VALUE "Hello Cobolana".

PROCEDURE DIVISION.
    CALL "sol_log_" USING
        BY REFERENCE HELLO-MSG
        BY VALUE 14.
    STOP RUN.
```

### Example 2: Counter with Arithmetic

```cobol
IDENTIFICATION DIVISION.
PROGRAM-ID. COUNTER.

DATA DIVISION.
WORKING-STORAGE SECTION.
01 NUM-COUNTER PIC 9(8) VALUE 0.

PROCEDURE DIVISION.
    ADD 1 TO NUM-COUNTER.
    DISPLAY NUM-COUNTER.
    STOP RUN.
```

Compiles to sBPF assembly:

```assembly
# Generated by cobolana-compiler (sBPF backend)
# Variable offsets in account data:
# NUM-COUNTER: offset 0x0071, size 8

.text
.globl entrypoint

entrypoint:
  # Save input parameter pointer (r1) to r6
  mov64 r6, r1

  # ADD 1 TO NUM-COUNTER
  ldxdw r2, [r6 + 0x71]
  add64 r2, 1
  stxdw [r6 + 0x71], r2

  lddw r0, 0
  exit
```

## What is this?

A complete COBOL-to-Solana compiler that:
- Takes COBOL source code from 1959
- Compiles it to Solana BPF bytecode
- Deploys it on-chain
- Executes successfully with minimal compute units

This is not a joke. This is not a wrapper. This is a **real compiler** using GnuCOBOL's full parser infrastructure (20,000+ line bison grammar) with a custom Solana BPF backend.

## Why does this exist?

1. **Because we can** - The ultimate test of "everything is a compiler target"
2. **For the memes** - COBOL on blockchain is peak absurdist programming
3. **Historical irony** - Grace Hopper's 1959 language running on 2020s distributed ledgers
4. **It's actually interesting** - Bridging 65+ years of computer science

## Architecture

```
COBOL Source (.cob)
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   cobolana-cc (GnuCOBOL-based compiler)  ‚îÇ
‚îÇ   - Full COBOL parser (parser.y)         ‚îÇ
‚îÇ   - Custom sBPF backend (codegen.c)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì
sBPF Assembly (.s)
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   sbpf build tool                        ‚îÇ
‚îÇ   - Assembles to ELF object              ‚îÇ
‚îÇ   - Links syscalls                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì
Solana BPF Program (.so)
       ‚Üì
solana-test-validator / Mainnet
```

## Quick Start

### Prerequisites

```bash
# Install Solana CLI tools
sh -c "$(curl -sSfL https://release.solana.com/stable/install)"

# Install Node.js dependencies
npm install

# Build GnuCOBOL-based compiler (one-time setup)
cd cobolana-cc
make
cd ..
```

### Build & Test

```bash
# Build COBOL ‚Üí Solana BPF
./build.sh

# Run end-to-end tests (deploys to local validator)
npm test
```

## Project Structure

```
cobolana/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ cobolana.cob          # COBOL source code
‚îÇ   ‚îî‚îÄ‚îÄ cobolana/             # Generated sBPF assembly (build artifact)
‚îú‚îÄ‚îÄ cobolana-cc/              # The compiler
‚îÇ   ‚îú‚îÄ‚îÄ codegen.c             # Custom Solana BPF backend
‚îÇ   ‚îú‚îÄ‚îÄ parser.y              # COBOL grammar (from GnuCOBOL)
‚îÇ   ‚îú‚îÄ‚îÄ scanner.l             # COBOL lexer
‚îÇ   ‚îî‚îÄ‚îÄ ...                   # Full GnuCOBOL infrastructure
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îî‚îÄ‚îÄ cobolana.test.ts      # Jest tests (deploy & verify on-chain)
‚îú‚îÄ‚îÄ build.sh                  # Build script
‚îî‚îÄ‚îÄ README.md                 # You are here
```

## How It Works

### 1. COBOL Parsing
Uses GnuCOBOL's industrial-strength COBOL parser:
- 20,000+ line bison grammar
- Full COBOL-85 compatibility
- Builds an AST of the program

### 2. Code Generation (codegen.c)
Custom backend that walks the AST and emits sBPF assembly:

```c
// From codegen.c - Generating a sol_log_ syscall
fprintf(out, "  lddw r1, msg_%s\n", field->name);  // Load string address
fprintf(out, "  lddw r2, %d\n", field->size);      // Load string length
fprintf(out, "  call sol_log_\n");                 // Syscall
```

Outputs valid sBPF assembly:
```assembly
.section .rodata
msg_HELLO_MSG:
  .ascii "Hello Cobolana"

.text
.globl entrypoint

entrypoint:
  lddw r1, msg_HELLO_MSG
  lddw r2, 14
  call sol_log_
  exit
```

### 3. Assembly & Linking
Uses the `sbpf` toolchain to:
- Assemble `.s` ‚Üí `.o` (ELF object)
- Link syscalls (sol_log_ ‚Üí 0x207559bd)
- Generate final `.so` binary

### 4. Deployment & Execution
Jest tests deploy to `solana-test-validator` and verify on-chain execution.

## Arithmetic Implementation

The compiler tracks COBOL variables and generates efficient sBPF load/store operations:

**Variable Tracking (`codegen.c`):**
```c
struct var_info {
    const char *name;
    int offset;        // Offset in account data
    int size;          // Size in bytes (8 for numerics)
    int reg;           // Assigned register
    int dirty;         // Needs writeback
};

static struct var_info variables[MAX_VARIABLES];
static int next_offset = 0x0060;  // Start offset

struct var_info *var = add_variable("NUM-COUNTER", 8);
// NUM-COUNTER gets offset 0x0060, size 8
```

**Code Generation for `ADD 1 TO NUM-COUNTER`:**
```c
// Detect cob_add_int funcall in AST
fprintf(out, "  # ADD %lld TO %s\n", val, var_name);
fprintf(out, "  ldxdw r2, [r6 + 0x%x]\n", var->offset);  // Load variable
fprintf(out, "  add64 r2, %lld\n", val);                  // Add immediate
fprintf(out, "  stxdw [r6 + 0x%x], r2\n", var->offset);  // Store result
```

**Binary Operations (`COMPUTE RESULT = A + B`):**
```c
// Detect CB_ASSIGN with CB_BINARY_OP
fprintf(out, "  ldxdw r2, [r6 + 0x%x]\n", op1_var->offset);
fprintf(out, "  ldxdw r3, [r6 + 0x%x]\n", op2_var->offset);
fprintf(out, "  add64 r2, r3\n");  // or sub64, mul64, div64
fprintf(out, "  stxdw [r6 + 0x%x], r2\n", dest_var->offset);
```

This maps directly to sBPF's register-based architecture with minimal overhead.

## Features

- ‚úÖ **Full COBOL parser** - Not a toy, uses production compiler infrastructure
- ‚úÖ **Arithmetic operations** - ADD, SUBTRACT, MULTIPLY compile to sBPF (add64/sub64/mul64)
- ‚úÖ **Variable tracking** - Working-storage variables mapped to account data offsets
- ‚úÖ **Real syscalls** - Calls Solana's `sol_log_` to write on-chain logs
- ‚úÖ **Minimal compute** - Efficient register-based operations
- ‚úÖ **End-to-end tests** - Automated deploy & verification
- ‚úÖ **Proper toolchain** - Integrates with sbpf assembler/linker

## Current Capabilities

### ‚úÖ What Works

**Arithmetic Operations:**
```cobol
ADD NUM-A TO NUM-B.
SUBTRACT NUM-A FROM NUM-B.
MULTIPLY NUM-A BY NUM-B.
COMPUTE RESULT = NUM-A + NUM-B.
COMPUTE RESULT = NUM-A * NUM-B.
```

These compile to efficient sBPF assembly:
```assembly
ldxdw r2, [r6 + 0x61]  # Load NUM-A
ldxdw r3, [r6 + 0x69]  # Load NUM-B
add64 r2, r3            # Add
stxdw [r6 + 0x71], r2  # Store to RESULT
```

**Variable Storage:**
- Numeric variables (PIC 9) allocated in account data
- 8 bytes per variable
- Fixed offset allocation (0x0060, 0x0068, 0x0070, etc.)
- Load/store via register r6

### ‚ö†Ô∏è Known Limitations

**Persistence Issue (Actively Being Fixed):**
- Variables currently use simplified offset model (0x60, 0x71, etc.)
- Solana's actual account serialization format is more complex
- Counter values don't persist across multiple calls
- **Root cause**: Need to parse Solana's account buffer structure (headers at 0x0000-0x0060, first account data at 0x0060, second account at 0x28c0, etc.)
- See [Issue #4b8a](https://github.com/vitorpy/cobolana/issues) for details

**Not Yet Implemented:**
- ‚ùå Division operations (requires decimal precision handling)
- ‚ùå Branching/conditionals (IF/ELSE)
- ‚ùå PERFORM loops
- ‚ùå String operations beyond logging
- ‚ùå DISPLAY statement (assembly generation works, syscall integration pending)

**But the compiler works, arithmetic compiles correctly, and we're fixing persistence next.** üöÄ

## Roadmap

**In Progress:**
- [x] ‚úÖ COBOL arithmetic operations (ADD, SUBTRACT, MULTIPLY)
- [ ] üîß Fix account data persistence (parsing Solana buffer format)
- [ ] üîß Integrate DISPLAY statement with sol_log_ syscall

**Next Up:**
- [ ] Division operations with COBOL decimal semantics
- [ ] IF/ELSE ‚Üí BPF conditional jumps
- [ ] PERFORM ‚Üí BPF subroutines
- [ ] Support more Solana syscalls (sol_log_64_, etc.)
- [ ] Deploy a COBOL counter to devnet (for the culture)

**Future Ideas:**
- [ ] Map COBOL file I/O to Solana accounts
- [ ] COBOL table operations ‚Üí account arrays
- [ ] Cross-program calls via CALL statement
- [ ] Mainnet deployment (the ultimate flex)

## The Story

This started as a joke: "What's the most absurd language to compile to Solana?"

COBOL won because:
1. **Maximum age gap** - 1959 vs 2020
2. **Cultural contrast** - Enterprise banking vs DeFi
3. **Technical challenge** - Complex grammar, different paradigms
4. **Meme potential** - Infinite

After 83,000+ lines of compiler code and many debugger sessions, **it works.**

```
Program log: Hello Cobolana
```

*Chef's kiss.* üë®‚Äçüç≥

## Credits

- **GnuCOBOL** - For the industrial-grade COBOL parser
- **sbpf toolchain** - For making sBPF assembly viable
- **Solana** - For being a compiler target that accepts anything
- **Grace Hopper** - For COBOL (sorry Grace, we did this to your baby)

## License

MIT - Do whatever you want with this madness

## Contributing

PRs welcome! Especially if you want to:
- Add more syscalls
- Implement COBOL arithmetic/branching
- Write more on-chain COBOL programs
- Make the error messages less terrifying

## Star This Repo

If this made you smile, give it a ‚≠ê

If this made you cry, also give it a ‚≠ê

If you worked in COBOL in the 80s and this triggered your PTSD, definitely give it a ‚≠ê

---

Built with ‚ù§Ô∏è and questionable life choices.

**COBOL on Solana. Because someone had to.**
